{"ast":null,"code":"'use strict';\n\nvar invariant = require('../../vendor/invariant');\n\nvar makeService = require('../make_service');\n/**\n * @class MapboxGeocoding\n */\n\n\nvar MapboxGeocoding = makeService('MapboxGeocoding');\nvar API_GEOCODING_FORWARD = '/geocoding/v5/{dataset}/{query}.json{?access_token,proximity,country,types,bbox,limit,autocomplete,language}';\nvar API_GEOCODING_REVERSE = '/geocoding/v5/{dataset}/{longitude},{latitude}.json{?access_token,types,limit,language}';\nvar REVERSE_GEOCODING_PRECISION = 5;\nvar FORWARD_GEOCODING_PROXIMITY_PRECISION = 3;\n\nfunction roundTo(value, places) {\n  var mult = Math.pow(10, places);\n  return Math.round(value * mult) / mult;\n}\n/**\n * Search for a location with a string, using the\n * [Mapbox Geocoding API](https://www.mapbox.com/api-documentation/#geocoding).\n *\n * The `query` parmeter can be an array of strings only if batch geocoding\n * is used by specifying `mapbox.places-permanent` as the `dataset` option.\n *\n * @param {string|Array<string>} query desired location\n * @param {Object} [options={}] additional options meant to tune\n * the request\n * @param {Object} options.proximity a proximity argument: this is\n * a geographical point given as an object with latitude and longitude\n * properties. Search results closer to this point will be given\n * higher priority.\n * @param {Array} options.bbox a bounding box argument: this is\n * a bounding box given as an array in the format [minX, minY, maxX, maxY].\n * Search results will be limited to the bounding box.\n * @param {Array<string>|string} options.language Specify the language to use for response text and, for forward geocoding, query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, as an array or separated by commas.\n * @param {Array<string>|string} options.types an array or comma seperated list of types that filter\n * results to match those specified. See https://www.mapbox.com/developers/api/geocoding/#filter-type\n * for available types.\n * @param {number} [options.limit=5] is the maximum number of results to return, between 1 and 10 inclusive.\n * Some very specific queries may return fewer results than the limit.\n * @param {Array<string>|string} options.country an array or comma separated list of country codes to\n * limit results to specified country or countries.\n * @param {boolean} [options.autocomplete=true] whether to include results that include\n * the query only as a prefix. This is useful for UIs where users type\n * values, but if you have complete addresses as input, you'll want to turn it off\n * @param {string} [options.dataset=mapbox.places] the desired data to be\n * geocoded against. The default, mapbox.places, does not permit unlimited\n * caching. `mapbox.places-permanent` is available on request and does\n * permit permanent caching.\n * @param {Function} callback called with (err, results)\n * @returns {Promise} response\n * @example\n * var mapboxClient = new MapboxClient('ACCESSTOKEN');\n * mapboxClient.geocodeForward('Paris, France', function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n * // using the proximity option to weight results closer to texas\n * mapboxClient.geocodeForward('Paris, France', {\n *   proximity: { latitude: 33.6875431, longitude: -95.4431142 }\n * }, function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n * // using the bbox option to limit results to a portion of Washington, D.C.\n * mapboxClient.geocodeForward('Starbucks', {\n *   bbox: [-77.083056,38.908611,-76.997778,38.959167]\n * }, function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n */\n\n\nMapboxGeocoding.prototype.geocodeForward = function (query, options, callback) {\n  // permit the options argument to be omitted, or the options + callback args to be omitted if using promise syntax\n  if (callback === undefined && (options === undefined || typeof options === 'function')) {\n    callback = options;\n    options = {};\n  } // typecheck arguments\n\n\n  if (Array.isArray(query)) {\n    if (options.dataset !== 'mapbox.places-permanent') {\n      throw new Error('Batch geocoding is only available with the mapbox.places-permanent endpoint. See https://mapbox.com/api-documentation/#batch-requests for details');\n    } else {\n      query = query.join(';');\n    }\n  }\n\n  invariant(typeof query === 'string', 'query must be a string');\n  invariant(typeof options === 'object', 'options must be an object');\n  var queryOptions = {\n    query: query,\n    dataset: 'mapbox.places'\n  };\n  var precision = FORWARD_GEOCODING_PROXIMITY_PRECISION;\n\n  if (options.precision) {\n    invariant(typeof options.precision === 'number', 'precision option must be number');\n    precision = options.precision;\n  }\n\n  if (options.proximity) {\n    invariant(typeof options.proximity.latitude === 'number' && typeof options.proximity.longitude === 'number', 'proximity must be an object with numeric latitude & longitude properties');\n    queryOptions.proximity = roundTo(options.proximity.longitude, precision) + ',' + roundTo(options.proximity.latitude, precision);\n  }\n\n  if (options.bbox) {\n    invariant(typeof options.bbox[0] === 'number' && typeof options.bbox[1] === 'number' && typeof options.bbox[2] === 'number' && typeof options.bbox[3] === 'number' && options.bbox.length === 4, 'bbox must be an array with numeric values in the form [minX, minY, maxX, maxY]');\n    queryOptions.bbox = options.bbox[0] + ',' + options.bbox[1] + ',' + options.bbox[2] + ',' + options.bbox[3];\n  }\n\n  if (options.limit) {\n    invariant(typeof options.limit === 'number', 'limit must be a number');\n    queryOptions.limit = options.limit;\n  }\n\n  if (options.dataset) {\n    invariant(typeof options.dataset === 'string', 'dataset option must be string');\n    queryOptions.dataset = options.dataset;\n  }\n\n  if (options.country) {\n    if (Array.isArray(options.country)) {\n      queryOptions.country = options.country.join(',');\n    } else {\n      invariant(typeof options.country === 'string', 'country option must be an array or string');\n      queryOptions.country = options.country;\n    }\n  }\n\n  if (options.language) {\n    if (Array.isArray(options.language)) {\n      queryOptions.language = options.language.join(',');\n    } else {\n      invariant(typeof options.language === 'string', 'language option must be an array or string');\n      queryOptions.language = options.language;\n    }\n  }\n\n  if (options.types) {\n    if (Array.isArray(options.types)) {\n      queryOptions.types = options.types.join(',');\n    } else {\n      invariant(typeof options.types === 'string', 'types option must be an array or string');\n      queryOptions.types = options.types;\n    }\n  }\n\n  if (typeof options.autocomplete === 'boolean') {\n    invariant(typeof options.autocomplete === 'boolean', 'autocomplete must be a boolean');\n    queryOptions.autocomplete = options.autocomplete;\n  }\n\n  return this.client({\n    path: API_GEOCODING_FORWARD,\n    params: queryOptions,\n    callback: callback\n  });\n};\n/**\n * Given a location, determine what geographical features are located\n * there. This uses the [Mapbox Geocoding API](https://www.mapbox.com/api-documentation/#geocoding).\n *\n * @param {Object} location the geographical point to search\n * @param {number} location.latitude decimal degrees latitude, in range -90 to 90\n * @param {number} location.longitude decimal degrees longitude, in range -180 to 180\n * @param {Object} [options={}] additional options meant to tune\n * the request.\n * @param {Array<string>|string} options.language Specify the language to use for response text and, for forward geocoding, query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas or as an array.\n * @param {Array<string>|string} options.types an array or comma seperated list of types that filter\n * results to match those specified. See\n * https://www.mapbox.com/api-documentation/#retrieve-places-near-a-location\n * for available types.\n * @param {number} [options.limit=1] is the maximum number of results to return, between 1 and 5\n * inclusive. Requires a single options.types to be specified (see example).\n * @param {string} [options.dataset=mapbox.places] the desired data to be\n * geocoded against. The default, mapbox.places, does not permit unlimited\n * caching. `mapbox.places-permanent` is available on request and does\n * permit permanent caching.\n * @param {Function} callback called with (err, results)\n * @returns {Promise} response\n * @example\n * var mapboxClient = new MapboxClient('ACCESSTOKEN');\n * mapboxClient.geocodeReverse(\n *   { latitude: 33.6875431, longitude: -95.4431142 },\n *   function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n * @example\n * var mapboxClient = new MapboxClient('ACCESSTOKEN');\n * mapboxClient.geocodeReverse(\n *   { latitude: 33.6875431, longitude: -95.4431142, options: { types: 'address', limit: 3 } },\n *   function(err, res) {\n *   // res is a GeoJSON document with up to 3 geocoding matches\n * });\n */\n\n\nMapboxGeocoding.prototype.geocodeReverse = function (location, options, callback) {\n  // permit the options argument to be omitted, or the options + callback args to be omitted if using promise syntax\n  if (callback === undefined && (options === undefined || typeof options === 'function')) {\n    callback = options;\n    options = {};\n  } // typecheck arguments\n\n\n  invariant(typeof location === 'object' && location !== null, 'location must be an object');\n  invariant(typeof options === 'object', 'options must be an object');\n  invariant(typeof location.latitude === 'number' && typeof location.longitude === 'number', 'location must be an object with numeric latitude & longitude properties');\n  var queryOptions = {\n    dataset: 'mapbox.places'\n  };\n\n  if (options.dataset) {\n    invariant(typeof options.dataset === 'string', 'dataset option must be string');\n    queryOptions.dataset = options.dataset;\n  }\n\n  var precision = REVERSE_GEOCODING_PRECISION;\n\n  if (options.precision) {\n    invariant(typeof options.precision === 'number', 'precision option must be number');\n    precision = options.precision;\n  }\n\n  if (options.language) {\n    if (Array.isArray(options.language)) {\n      queryOptions.language = options.language.join(',');\n    } else {\n      invariant(typeof options.language === 'string', 'language option must be an array or string');\n      queryOptions.language = options.language;\n    }\n  }\n\n  if (options.types) {\n    if (Array.isArray(options.types)) {\n      queryOptions.types = options.types.join(',');\n    } else {\n      invariant(typeof options.types === 'string', 'types option must be an array or string');\n      queryOptions.types = options.types;\n    }\n  }\n\n  if (options.limit) {\n    invariant(typeof options.limit === 'number', 'limit option must be a number');\n    invariant(options.types.split(',').length === 1, 'a single type must be specified to use the limit option');\n    queryOptions.limit = options.limit;\n  }\n\n  queryOptions.longitude = roundTo(location.longitude, precision);\n  queryOptions.latitude = roundTo(location.latitude, precision);\n  return this.client({\n    path: API_GEOCODING_REVERSE,\n    params: queryOptions,\n    callback: callback\n  });\n};\n\nmodule.exports = MapboxGeocoding;","map":{"version":3,"sources":["/Users/HHJ/Dropbox/Class/2021/DSCI554/Github/project-datadocs/demo/node_modules/mapbox/lib/services/geocoding.js"],"names":["invariant","require","makeService","MapboxGeocoding","API_GEOCODING_FORWARD","API_GEOCODING_REVERSE","REVERSE_GEOCODING_PRECISION","FORWARD_GEOCODING_PROXIMITY_PRECISION","roundTo","value","places","mult","Math","pow","round","prototype","geocodeForward","query","options","callback","undefined","Array","isArray","dataset","Error","join","queryOptions","precision","proximity","latitude","longitude","bbox","length","limit","country","language","types","autocomplete","client","path","params","geocodeReverse","location","split","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar invariant = require('../../vendor/invariant');\nvar makeService = require('../make_service');\n\n/**\n * @class MapboxGeocoding\n */\nvar MapboxGeocoding = makeService('MapboxGeocoding');\n\nvar API_GEOCODING_FORWARD = '/geocoding/v5/{dataset}/{query}.json{?access_token,proximity,country,types,bbox,limit,autocomplete,language}';\nvar API_GEOCODING_REVERSE = '/geocoding/v5/{dataset}/{longitude},{latitude}.json{?access_token,types,limit,language}';\n\nvar REVERSE_GEOCODING_PRECISION = 5;\nvar FORWARD_GEOCODING_PROXIMITY_PRECISION = 3;\n\nfunction roundTo(value, places) {\n  var mult = Math.pow(10, places);\n  return Math.round(value * mult) / mult;\n}\n\n/**\n * Search for a location with a string, using the\n * [Mapbox Geocoding API](https://www.mapbox.com/api-documentation/#geocoding).\n *\n * The `query` parmeter can be an array of strings only if batch geocoding\n * is used by specifying `mapbox.places-permanent` as the `dataset` option.\n *\n * @param {string|Array<string>} query desired location\n * @param {Object} [options={}] additional options meant to tune\n * the request\n * @param {Object} options.proximity a proximity argument: this is\n * a geographical point given as an object with latitude and longitude\n * properties. Search results closer to this point will be given\n * higher priority.\n * @param {Array} options.bbox a bounding box argument: this is\n * a bounding box given as an array in the format [minX, minY, maxX, maxY].\n * Search results will be limited to the bounding box.\n * @param {Array<string>|string} options.language Specify the language to use for response text and, for forward geocoding, query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, as an array or separated by commas.\n * @param {Array<string>|string} options.types an array or comma seperated list of types that filter\n * results to match those specified. See https://www.mapbox.com/developers/api/geocoding/#filter-type\n * for available types.\n * @param {number} [options.limit=5] is the maximum number of results to return, between 1 and 10 inclusive.\n * Some very specific queries may return fewer results than the limit.\n * @param {Array<string>|string} options.country an array or comma separated list of country codes to\n * limit results to specified country or countries.\n * @param {boolean} [options.autocomplete=true] whether to include results that include\n * the query only as a prefix. This is useful for UIs where users type\n * values, but if you have complete addresses as input, you'll want to turn it off\n * @param {string} [options.dataset=mapbox.places] the desired data to be\n * geocoded against. The default, mapbox.places, does not permit unlimited\n * caching. `mapbox.places-permanent` is available on request and does\n * permit permanent caching.\n * @param {Function} callback called with (err, results)\n * @returns {Promise} response\n * @example\n * var mapboxClient = new MapboxClient('ACCESSTOKEN');\n * mapboxClient.geocodeForward('Paris, France', function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n * // using the proximity option to weight results closer to texas\n * mapboxClient.geocodeForward('Paris, France', {\n *   proximity: { latitude: 33.6875431, longitude: -95.4431142 }\n * }, function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n * // using the bbox option to limit results to a portion of Washington, D.C.\n * mapboxClient.geocodeForward('Starbucks', {\n *   bbox: [-77.083056,38.908611,-76.997778,38.959167]\n * }, function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n */\nMapboxGeocoding.prototype.geocodeForward = function(query, options, callback) {\n  // permit the options argument to be omitted, or the options + callback args to be omitted if using promise syntax\n  if (callback === undefined && (options === undefined || typeof options === 'function')) {\n    callback = options;\n    options = {};\n  }\n\n  // typecheck arguments\n  if (Array.isArray(query)) {\n    if (options.dataset !== 'mapbox.places-permanent') {\n      throw new Error('Batch geocoding is only available with the mapbox.places-permanent endpoint. See https://mapbox.com/api-documentation/#batch-requests for details');\n    } else {\n      query = query.join(';');\n    }\n  }\n  invariant(typeof query === 'string', 'query must be a string');\n  invariant(typeof options === 'object', 'options must be an object');\n\n  var queryOptions = {\n    query: query,\n    dataset: 'mapbox.places'\n  };\n\n  var precision = FORWARD_GEOCODING_PROXIMITY_PRECISION;\n  if (options.precision) {\n    invariant(typeof options.precision === 'number', 'precision option must be number');\n    precision = options.precision;\n  }\n\n  if (options.proximity) {\n    invariant(typeof options.proximity.latitude === 'number' &&\n      typeof options.proximity.longitude === 'number',\n      'proximity must be an object with numeric latitude & longitude properties');\n    queryOptions.proximity = roundTo(options.proximity.longitude, precision) + ',' + roundTo(options.proximity.latitude, precision);\n  }\n\n  if (options.bbox) {\n    invariant(typeof options.bbox[0] === 'number' &&\n      typeof options.bbox[1] === 'number' &&\n      typeof options.bbox[2] === 'number' &&\n      typeof options.bbox[3] === 'number' &&\n      options.bbox.length === 4,\n      'bbox must be an array with numeric values in the form [minX, minY, maxX, maxY]');\n    queryOptions.bbox = options.bbox[0] + ',' + options.bbox[1] + ',' + options.bbox[2] + ',' + options.bbox[3];\n  }\n\n  if (options.limit) {\n    invariant(typeof options.limit === 'number',\n      'limit must be a number');\n    queryOptions.limit = options.limit;\n  }\n\n  if (options.dataset) {\n    invariant(typeof options.dataset === 'string', 'dataset option must be string');\n    queryOptions.dataset = options.dataset;\n  }\n\n  if (options.country) {\n    if (Array.isArray(options.country)) {\n      queryOptions.country = options.country.join(',');\n    } else {\n      invariant(typeof options.country === 'string', 'country option must be an array or string');\n      queryOptions.country = options.country;\n    }\n  }\n\n  if (options.language) {\n    if (Array.isArray(options.language)) {\n      queryOptions.language = options.language.join(',');\n    } else {\n      invariant(typeof options.language === 'string', 'language option must be an array or string');\n      queryOptions.language = options.language;\n    }\n  }\n\n  if (options.types) {\n    if (Array.isArray(options.types)) {\n      queryOptions.types = options.types.join(',');\n    } else {\n      invariant(typeof options.types === 'string', 'types option must be an array or string');\n      queryOptions.types = options.types;\n    }\n  }\n\n  if (typeof options.autocomplete === 'boolean') {\n    invariant(typeof options.autocomplete === 'boolean', 'autocomplete must be a boolean');\n    queryOptions.autocomplete = options.autocomplete;\n  }\n\n  return this.client({\n    path: API_GEOCODING_FORWARD,\n    params: queryOptions,\n    callback: callback\n  });\n};\n\n/**\n * Given a location, determine what geographical features are located\n * there. This uses the [Mapbox Geocoding API](https://www.mapbox.com/api-documentation/#geocoding).\n *\n * @param {Object} location the geographical point to search\n * @param {number} location.latitude decimal degrees latitude, in range -90 to 90\n * @param {number} location.longitude decimal degrees longitude, in range -180 to 180\n * @param {Object} [options={}] additional options meant to tune\n * the request.\n * @param {Array<string>|string} options.language Specify the language to use for response text and, for forward geocoding, query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas or as an array.\n * @param {Array<string>|string} options.types an array or comma seperated list of types that filter\n * results to match those specified. See\n * https://www.mapbox.com/api-documentation/#retrieve-places-near-a-location\n * for available types.\n * @param {number} [options.limit=1] is the maximum number of results to return, between 1 and 5\n * inclusive. Requires a single options.types to be specified (see example).\n * @param {string} [options.dataset=mapbox.places] the desired data to be\n * geocoded against. The default, mapbox.places, does not permit unlimited\n * caching. `mapbox.places-permanent` is available on request and does\n * permit permanent caching.\n * @param {Function} callback called with (err, results)\n * @returns {Promise} response\n * @example\n * var mapboxClient = new MapboxClient('ACCESSTOKEN');\n * mapboxClient.geocodeReverse(\n *   { latitude: 33.6875431, longitude: -95.4431142 },\n *   function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n * @example\n * var mapboxClient = new MapboxClient('ACCESSTOKEN');\n * mapboxClient.geocodeReverse(\n *   { latitude: 33.6875431, longitude: -95.4431142, options: { types: 'address', limit: 3 } },\n *   function(err, res) {\n *   // res is a GeoJSON document with up to 3 geocoding matches\n * });\n */\nMapboxGeocoding.prototype.geocodeReverse = function(location, options, callback) {\n  // permit the options argument to be omitted, or the options + callback args to be omitted if using promise syntax\n  if (callback === undefined && (options === undefined || typeof options === 'function')) {\n    callback = options;\n    options = {};\n  }\n\n  // typecheck arguments\n  invariant((typeof location === 'object' && location !== null), 'location must be an object');\n  invariant(typeof options === 'object', 'options must be an object');\n\n  invariant(typeof location.latitude === 'number' &&\n    typeof location.longitude === 'number',\n    'location must be an object with numeric latitude & longitude properties');\n\n  var queryOptions = {\n    dataset: 'mapbox.places'\n  };\n\n  if (options.dataset) {\n    invariant(typeof options.dataset === 'string', 'dataset option must be string');\n    queryOptions.dataset = options.dataset;\n  }\n\n  var precision = REVERSE_GEOCODING_PRECISION;\n  if (options.precision) {\n    invariant(typeof options.precision === 'number', 'precision option must be number');\n    precision = options.precision;\n  }\n\n  if (options.language) {\n    if (Array.isArray(options.language)) {\n      queryOptions.language = options.language.join(',');\n    } else {\n      invariant(typeof options.language === 'string', 'language option must be an array or string');\n      queryOptions.language = options.language;\n    }\n  }\n\n  if (options.types) {\n    if (Array.isArray(options.types)) {\n      queryOptions.types = options.types.join(',');\n    } else {\n      invariant(typeof options.types === 'string', 'types option must be an array or string');\n      queryOptions.types = options.types;\n    }\n  }\n\n  if (options.limit) {\n    invariant(typeof options.limit === 'number', 'limit option must be a number');\n    invariant(options.types.split(',').length === 1, 'a single type must be specified to use the limit option');\n    queryOptions.limit = options.limit;\n  }\n\n  queryOptions.longitude = roundTo(location.longitude, precision);\n  queryOptions.latitude = roundTo(location.latitude, precision);\n\n  return this.client({\n    path: API_GEOCODING_REVERSE,\n    params: queryOptions,\n    callback: callback\n  });\n};\n\nmodule.exports = MapboxGeocoding;\n"]},"metadata":{},"sourceType":"script"}