{"ast":null,"code":"'use strict';\n/*\n * polyline\n *\n * https://github.com/mapbox/polyline\n *\n * by John Firebaugh, Tom MacWright, and contributors\n * licensed under BSD 3-clause\n */\n\n/*\n * Based off of [the offical Google document](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)\n *\n * Some parts from [this implementation](http://facstaff.unca.edu/mcmcclur/GoogleMaps/EncodePolyline/PolylineEncoder.js)\n * by [Mark McClure](http://facstaff.unca.edu/mcmcclur/)\n *\n * @module polyline\n */\n\nvar polyline = {};\n\nfunction encode(coordinate, factor) {\n  coordinate = Math.round(coordinate * factor);\n  coordinate <<= 1;\n\n  if (coordinate < 0) {\n    coordinate = ~coordinate;\n  }\n\n  var output = '';\n\n  while (coordinate >= 0x20) {\n    output += String.fromCharCode((0x20 | coordinate & 0x1f) + 63);\n    coordinate >>= 5;\n  }\n\n  output += String.fromCharCode(coordinate + 63);\n  return output;\n}\n/**\n * Encodes the given [latitude, longitude] coordinates array.\n *\n * @param {Array.<Array.<Number>>} coordinates\n * @param {Number} precision\n * @returns {String}\n */\n\n\npolyline.encode = function (coordinates, precision) {\n  if (!coordinates.length) {\n    return '';\n  }\n\n  var factor = Math.pow(10, precision || 5),\n      output = encode(coordinates[0][0], factor) + encode(coordinates[0][1], factor);\n\n  for (var i = 1; i < coordinates.length; i++) {\n    var a = coordinates[i],\n        b = coordinates[i - 1];\n    output += encode(a[0] - b[0], factor);\n    output += encode(a[1] - b[1], factor);\n  }\n\n  return output;\n};\n\nfunction flipped(coords) {\n  var flipped = [];\n\n  for (var i = 0; i < coords.length; i++) {\n    flipped.push(coords[i].slice().reverse());\n  }\n\n  return flipped;\n}\n/**\n * Encodes a GeoJSON LineString feature/geometry.\n *\n * @param {Object} geojson\n * @param {Number} precision\n * @returns {String}\n */\n\n\npolyline.fromGeoJSON = function (geojson, precision) {\n  if (geojson && geojson.type === 'Feature') {\n    geojson = geojson.geometry;\n  }\n\n  if (!geojson || geojson.type !== 'LineString') {\n    throw new Error('Input must be a GeoJSON LineString');\n  }\n\n  return polyline.encode(flipped(geojson.coordinates), precision);\n};\n\nmodule.exports = polyline;","map":{"version":3,"sources":["/Users/kevinrayjon/Documents/USC_MS_ADS/Fall_2021/DSCI_554/Project/project-datadocs/demo/node_modules/mapbox/vendor/polyline.js"],"names":["polyline","encode","coordinate","factor","Math","round","output","String","fromCharCode","coordinates","precision","length","pow","i","a","b","flipped","coords","push","slice","reverse","fromGeoJSON","geojson","type","geometry","Error","module","exports"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,QAAQ,GAAG,EAAf;;AAEA,SAASC,MAAT,CAAgBC,UAAhB,EAA4BC,MAA5B,EAAoC;AAChCD,EAAAA,UAAU,GAAGE,IAAI,CAACC,KAAL,CAAWH,UAAU,GAAGC,MAAxB,CAAb;AACAD,EAAAA,UAAU,KAAK,CAAf;;AACA,MAAIA,UAAU,GAAG,CAAjB,EAAoB;AAChBA,IAAAA,UAAU,GAAG,CAACA,UAAd;AACH;;AACD,MAAII,MAAM,GAAG,EAAb;;AACA,SAAOJ,UAAU,IAAI,IAArB,EAA2B;AACvBI,IAAAA,MAAM,IAAIC,MAAM,CAACC,YAAP,CAAoB,CAAC,OAAQN,UAAU,GAAG,IAAtB,IAA+B,EAAnD,CAAV;AACAA,IAAAA,UAAU,KAAK,CAAf;AACH;;AACDI,EAAAA,MAAM,IAAIC,MAAM,CAACC,YAAP,CAAoBN,UAAU,GAAG,EAAjC,CAAV;AACA,SAAOI,MAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAN,QAAQ,CAACC,MAAT,GAAkB,UAASQ,WAAT,EAAsBC,SAAtB,EAAiC;AAC/C,MAAI,CAACD,WAAW,CAACE,MAAjB,EAAyB;AAAE,WAAO,EAAP;AAAY;;AAEvC,MAAIR,MAAM,GAAGC,IAAI,CAACQ,GAAL,CAAS,EAAT,EAAaF,SAAS,IAAI,CAA1B,CAAb;AAAA,MACIJ,MAAM,GAAGL,MAAM,CAACQ,WAAW,CAAC,CAAD,CAAX,CAAe,CAAf,CAAD,EAAoBN,MAApB,CAAN,GAAoCF,MAAM,CAACQ,WAAW,CAAC,CAAD,CAAX,CAAe,CAAf,CAAD,EAAoBN,MAApB,CADvD;;AAGA,OAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,WAAW,CAACE,MAAhC,EAAwCE,CAAC,EAAzC,EAA6C;AACzC,QAAIC,CAAC,GAAGL,WAAW,CAACI,CAAD,CAAnB;AAAA,QAAwBE,CAAC,GAAGN,WAAW,CAACI,CAAC,GAAG,CAAL,CAAvC;AACAP,IAAAA,MAAM,IAAIL,MAAM,CAACa,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAT,EAAcZ,MAAd,CAAhB;AACAG,IAAAA,MAAM,IAAIL,MAAM,CAACa,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAT,EAAcZ,MAAd,CAAhB;AACH;;AAED,SAAOG,MAAP;AACH,CAbD;;AAeA,SAASU,OAAT,CAAiBC,MAAjB,EAAyB;AACrB,MAAID,OAAO,GAAG,EAAd;;AACA,OAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,MAAM,CAACN,MAA3B,EAAmCE,CAAC,EAApC,EAAwC;AACpCG,IAAAA,OAAO,CAACE,IAAR,CAAaD,MAAM,CAACJ,CAAD,CAAN,CAAUM,KAAV,GAAkBC,OAAlB,EAAb;AACH;;AACD,SAAOJ,OAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAhB,QAAQ,CAACqB,WAAT,GAAuB,UAASC,OAAT,EAAkBZ,SAAlB,EAA6B;AAChD,MAAIY,OAAO,IAAIA,OAAO,CAACC,IAAR,KAAiB,SAAhC,EAA2C;AACvCD,IAAAA,OAAO,GAAGA,OAAO,CAACE,QAAlB;AACH;;AACD,MAAI,CAACF,OAAD,IAAYA,OAAO,CAACC,IAAR,KAAiB,YAAjC,EAA+C;AAC3C,UAAM,IAAIE,KAAJ,CAAU,oCAAV,CAAN;AACH;;AACD,SAAOzB,QAAQ,CAACC,MAAT,CAAgBe,OAAO,CAACM,OAAO,CAACb,WAAT,CAAvB,EAA8CC,SAA9C,CAAP;AACH,CARD;;AAUAgB,MAAM,CAACC,OAAP,GAAiB3B,QAAjB","sourcesContent":["'use strict';\n\n/*\n * polyline\n *\n * https://github.com/mapbox/polyline\n *\n * by John Firebaugh, Tom MacWright, and contributors\n * licensed under BSD 3-clause\n */\n\n/*\n * Based off of [the offical Google document](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)\n *\n * Some parts from [this implementation](http://facstaff.unca.edu/mcmcclur/GoogleMaps/EncodePolyline/PolylineEncoder.js)\n * by [Mark McClure](http://facstaff.unca.edu/mcmcclur/)\n *\n * @module polyline\n */\n\nvar polyline = {};\n\nfunction encode(coordinate, factor) {\n    coordinate = Math.round(coordinate * factor);\n    coordinate <<= 1;\n    if (coordinate < 0) {\n        coordinate = ~coordinate;\n    }\n    var output = '';\n    while (coordinate >= 0x20) {\n        output += String.fromCharCode((0x20 | (coordinate & 0x1f)) + 63);\n        coordinate >>= 5;\n    }\n    output += String.fromCharCode(coordinate + 63);\n    return output;\n}\n\n/**\n * Encodes the given [latitude, longitude] coordinates array.\n *\n * @param {Array.<Array.<Number>>} coordinates\n * @param {Number} precision\n * @returns {String}\n */\npolyline.encode = function(coordinates, precision) {\n    if (!coordinates.length) { return ''; }\n\n    var factor = Math.pow(10, precision || 5),\n        output = encode(coordinates[0][0], factor) + encode(coordinates[0][1], factor);\n\n    for (var i = 1; i < coordinates.length; i++) {\n        var a = coordinates[i], b = coordinates[i - 1];\n        output += encode(a[0] - b[0], factor);\n        output += encode(a[1] - b[1], factor);\n    }\n\n    return output;\n};\n\nfunction flipped(coords) {\n    var flipped = [];\n    for (var i = 0; i < coords.length; i++) {\n        flipped.push(coords[i].slice().reverse());\n    }\n    return flipped;\n}\n\n/**\n * Encodes a GeoJSON LineString feature/geometry.\n *\n * @param {Object} geojson\n * @param {Number} precision\n * @returns {String}\n */\npolyline.fromGeoJSON = function(geojson, precision) {\n    if (geojson && geojson.type === 'Feature') {\n        geojson = geojson.geometry;\n    }\n    if (!geojson || geojson.type !== 'LineString') {\n        throw new Error('Input must be a GeoJSON LineString');\n    }\n    return polyline.encode(flipped(geojson.coordinates), precision);\n};\n\nmodule.exports = polyline;\n"]},"metadata":{},"sourceType":"script"}