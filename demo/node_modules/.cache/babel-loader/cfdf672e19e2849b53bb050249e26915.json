{"ast":null,"code":"import * as d3 from 'd3';\nexport function drawSankey(height, width) {// d3.sankey = function() {\n  //     var sankey = {},\n  //         nodeWidth = 24,\n  //         nodePadding = 8,\n  //         size = [1, 1],\n  //         nodes = [],\n  //         links = [];\n  //     sankey.nodeWidth = function(_) {\n  //       if (!arguments.length) return nodeWidth;\n  //       nodeWidth = +_;\n  //       return sankey;\n  //     };\n  //     sankey.nodePadding = function(_) {\n  //       if (!arguments.length) return nodePadding;\n  //       nodePadding = +_;\n  //       return sankey;\n  //     };\n  //     sankey.nodes = function(_) {\n  //       if (!arguments.length) return nodes;\n  //       nodes = _;\n  //       return sankey;\n  //     };\n  //     sankey.links = function(_) {\n  //       if (!arguments.length) return links;\n  //       links = _;\n  //       return sankey;\n  //     };\n  //     sankey.size = function(_) {\n  //       if (!arguments.length) return size;\n  //       size = _;\n  //       return sankey;\n  //     };\n  //     sankey.layout = function(iterations) {\n  //       computeNodeLinks();\n  //       computeNodeValues();\n  //       computeNodeBreadths();\n  //       computeNodeDepths(iterations);\n  //       computeLinkDepths();\n  //       return sankey;\n  //     };\n  //     sankey.relayout = function() {\n  //       computeLinkDepths();\n  //       return sankey;\n  //     };\n  //     sankey.link = function() {\n  //       var curvature = .5;\n  //       function link(d) {\n  //         var x0 = d.source.x + d.source.dx,\n  //             x1 = d.target.x,\n  //             xi = d3.interpolateNumber(x0, x1),\n  //             x2 = xi(curvature),\n  //             x3 = xi(1 - curvature),\n  //             y0 = d.source.y + d.sy + d.dy / 2,\n  //             y1 = d.target.y + d.ty + d.dy / 2;\n  //         return \"M\" + x0 + \",\" + y0\n  //              + \"C\" + x2 + \",\" + y0\n  //              + \" \" + x3 + \",\" + y1\n  //              + \" \" + x1 + \",\" + y1;\n  //       }\n  //       link.curvature = function(_) {\n  //         if (!arguments.length) return curvature;\n  //         curvature = +_;\n  //         return link;\n  //       };\n  //       return link;\n  //     };\n  //     // Populate the sourceLinks and targetLinks for each node.\n  //     // Also, if the source and target are not objects, assume they are indices.\n  //     function computeNodeLinks() {\n  //       nodes.forEach(function(node) {\n  //         node.sourceLinks = [];\n  //         node.targetLinks = [];\n  //       });\n  //       links.forEach(function(link) {\n  //         var source = link.source,\n  //             target = link.target;\n  //         if (typeof source === \"number\") source = link.source = nodes[link.source];\n  //         if (typeof target === \"number\") target = link.target = nodes[link.target];\n  //         source.sourceLinks.push(link);\n  //         target.targetLinks.push(link);\n  //       });\n  //     }\n  //     // Compute the value (size) of each node by summing the associated links.\n  //     function computeNodeValues() {\n  //       nodes.forEach(function(node) {\n  //         node.value = Math.max(\n  //           d3.sum(node.sourceLinks, value),\n  //           d3.sum(node.targetLinks, value)\n  //         );\n  //       });\n  //     }\n  //     // Iteratively assign the breadth (x-position) for each node.\n  //     // Nodes are assigned the maximum breadth of incoming neighbors plus one;\n  //     // nodes with no incoming links are assigned breadth zero, while\n  //     // nodes with no outgoing links are assigned the maximum breadth.\n  //     function computeNodeBreadths() {\n  //       var remainingNodes = nodes,\n  //           nextNodes,\n  //           x = 0;\n  //       while (remainingNodes.length) {\n  //         nextNodes = [];\n  //         remainingNodes.forEach(function(node) {\n  //           node.x = x;\n  //           node.dx = nodeWidth;\n  //           node.sourceLinks.forEach(function(link) {\n  //             if (nextNodes.indexOf(link.target) < 0) {\n  //               nextNodes.push(link.target);\n  //             }\n  //           });\n  //         });\n  //         remainingNodes = nextNodes;\n  //         ++x;\n  //       }\n  //       //\n  //       moveSinksRight(x);\n  //       scaleNodeBreadths((size[0] - nodeWidth) / (x - 1));\n  //     }\n  //     function moveSourcesRight() {\n  //       nodes.forEach(function(node) {\n  //         if (!node.targetLinks.length) {\n  //           node.x = d3.min(node.sourceLinks, function(d) { return d.target.x; }) - 1;\n  //         }\n  //       });\n  //     }\n  //     function moveSinksRight(x) {\n  //       nodes.forEach(function(node) {\n  //         if (!node.sourceLinks.length) {\n  //           node.x = x - 1;\n  //         }\n  //       });\n  //     }\n  //     function scaleNodeBreadths(kx) {\n  //       nodes.forEach(function(node) {\n  //         node.x *= kx;\n  //       });\n  //     }\n  //     function computeNodeDepths(iterations) {\n  //       var nodesByBreadth = d3.nest()\n  //           .key(function(d) { return d.x; })\n  //           .sortKeys(d3.ascending)\n  //           .entries(nodes)\n  //           .map(function(d) { return d.values; });\n  //       //\n  //       initializeNodeDepth();\n  //       resolveCollisions();\n  //       for (var alpha = 1; iterations > 0; --iterations) {\n  //         relaxRightToLeft(alpha *= .99);\n  //         resolveCollisions();\n  //         relaxLeftToRight(alpha);\n  //         resolveCollisions();\n  //       }\n  //       function initializeNodeDepth() {\n  //         var ky = d3.min(nodesByBreadth, function(nodes) {\n  //           return (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value);\n  //         });\n  //         nodesByBreadth.forEach(function(nodes) {\n  //           nodes.forEach(function(node, i) {\n  //             node.y = i;\n  //             node.dy = node.value * ky;\n  //           });\n  //         });\n  //         links.forEach(function(link) {\n  //           link.dy = link.value * ky;\n  //         });\n  //       }\n  //       function relaxLeftToRight(alpha) {\n  //         nodesByBreadth.forEach(function(nodes, breadth) {\n  //           nodes.forEach(function(node) {\n  //             if (node.targetLinks.length) {\n  //               var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);\n  //               node.y += (y - center(node)) * alpha;\n  //             }\n  //           });\n  //         });\n  //         function weightedSource(link) {\n  //           return center(link.source) * link.value;\n  //         }\n  //       }\n  //       function relaxRightToLeft(alpha) {\n  //         nodesByBreadth.slice().reverse().forEach(function(nodes) {\n  //           nodes.forEach(function(node) {\n  //             if (node.sourceLinks.length) {\n  //               var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);\n  //               node.y += (y - center(node)) * alpha;\n  //             }\n  //           });\n  //         });\n  //         function weightedTarget(link) {\n  //           return center(link.target) * link.value;\n  //         }\n  //       }\n  //       function resolveCollisions() {\n  //         nodesByBreadth.forEach(function(nodes) {\n  //           var node,\n  //               dy,\n  //               y0 = 0,\n  //               n = nodes.length,\n  //               i;\n  //           // Push any overlapping nodes down.\n  //           nodes.sort(ascendingDepth);\n  //           for (i = 0; i < n; ++i) {\n  //             node = nodes[i];\n  //             dy = y0 - node.y;\n  //             if (dy > 0) node.y += dy;\n  //             y0 = node.y + node.dy + nodePadding;\n  //           }\n  //           // If the bottommost node goes outside the bounds, push it back up.\n  //           dy = y0 - nodePadding - size[1];\n  //           if (dy > 0) {\n  //             y0 = node.y -= dy;\n  //             // Push any overlapping nodes back up.\n  //             for (i = n - 2; i >= 0; --i) {\n  //               node = nodes[i];\n  //               dy = node.y + node.dy + nodePadding - y0;\n  //               if (dy > 0) node.y -= dy;\n  //               y0 = node.y;\n  //             }\n  //           }\n  //         });\n  //       }\n  //       function ascendingDepth(a, b) {\n  //         return a.y - b.y;\n  //       }\n  //     }\n  //     function computeLinkDepths() {\n  //       nodes.forEach(function(node) {\n  //         node.sourceLinks.sort(ascendingTargetDepth);\n  //         node.targetLinks.sort(ascendingSourceDepth);\n  //       });\n  //       nodes.forEach(function(node) {\n  //         var sy = 0, ty = 0;\n  //         node.sourceLinks.forEach(function(link) {\n  //           link.sy = sy;\n  //           sy += link.dy;\n  //         });\n  //         node.targetLinks.forEach(function(link) {\n  //           link.ty = ty;\n  //           ty += link.dy;\n  //         });\n  //       });\n  //       function ascendingSourceDepth(a, b) {\n  //         return a.source.y - b.source.y;\n  //       }\n  //       function ascendingTargetDepth(a, b) {\n  //         return a.target.y - b.target.y;\n  //       }\n  //     }\n  //     function center(node) {\n  //       return node.y + node.dy / 2;\n  //     }\n  //     function value(link) {\n  //       return link.value;\n  //     }\n  //     return sankey;\n  //   };\n  // /////////////////////////////////////////////////////////////////\n  // var units = \"Widgets\";\n  // // set the dimensions and margins of the graph\n  // var margin = {top: 10, right: 10, bottom: 10, left: 10},\n  //     width = 900 - margin.left - margin.right,\n  //     height = 300 - margin.top - margin.bottom;\n  // // format variables\n  // var formatNumber = d3.format(\",.0f\"),    // zero decimal places\n  //     format = function(d) { return formatNumber(d) + \" \" + units; },\n  //     color = d3.scaleOrdinal(d3.schemeCategory10);\n  //     // color = [\"#003f5c\",\"#2f4b7c\",\"#665191\",\"#a05195\",\"#d45087\",\"#f95d6a\",\"#ff7c43\",\"#ffa600\",\"#003f5c\",\"#2f4b7c\"];\n  // // append the svg object to the body of the page\n  // var svg = d3.select('#sankey1').append(\"svg\")\n  //     .attr(\"width\", width + margin.left + margin.right)\n  //     .attr(\"height\", height + margin.top + margin.bottom)\n  //   .append(\"g\")\n  //     .attr(\"transform\", \n  //           \"translate(\" + margin.left + \",\" + margin.top + \")\");\n  // // Set the sankey diagram properties\n  // var sankey = d3.sankey()\n  //     .nodeWidth(36)\n  //     .nodePadding(40)\n  //     .size([width, height]);\n  // var path = sankey.link();\n  // sankey_data = d3.csv(\"https://raw.githubusercontent.com/Heun-Johnson/dsci554projectdata/main/sankey.csv\")\n  // // load the data\n  // d3.csv(sankey_data, function(error, data) {\n  //   //set up graph in same style as original example but empty\n  //   graph = {\"nodes\" : [], \"links\" : []};\n  //   data.forEach(function (d) {\n  //     graph.nodes.push({ \"name\": d.source });\n  //     graph.nodes.push({ \"name\": d.target });\n  //     graph.links.push({ \"source\": d.source,\n  //                        \"target\": d.target,\n  //                        \"value\": +d.value });\n  //    });\n  //   // return only the distinct / unique nodes\n  //   graph.nodes = d3.keys(d3.nest()\n  //     .key(function (d) { return d.name; })\n  //     .object(graph.nodes));\n  //   // loop through each link replacing the text with its index from node\n  //   graph.links.forEach(function (d, i) {\n  //     graph.links[i].source = graph.nodes.indexOf(graph.links[i].source);\n  //     graph.links[i].target = graph.nodes.indexOf(graph.links[i].target);\n  //   });\n  //   // now loop through each nodes to make nodes an array of objects\n  //   // rather than an array of strings\n  //   graph.nodes.forEach(function (d, i) {\n  //     graph.nodes[i] = { \"name\": d };\n  //   });\n  //   sankey\n  //       .nodes(graph.nodes)\n  //       .links(graph.links)\n  //       .layout(32);\n  //   // add in the links\n  //   var link = svg.append(\"g\").selectAll(\".link\")\n  //       .data(graph.links)\n  //     .enter().append(\"path\")\n  //       .attr(\"class\", \"link\")\n  //       .attr(\"d\", path)\n  //       .style(\"stroke-width\", function(d) { return Math.max(1, d.dy); })\n  //       .sort(function(a, b) { return b.dy - a.dy; });\n  //   // add the link titles\n  //   link.append(\"title\")\n  //         .text(function(d) {\n  //             return d.source.name + \" → \" + \n  //                 d.target.name + \"\\n\" + format(d.value); });\n  //   // add in the nodes\n  //   var node = svg.append(\"g\").selectAll(\".node\")\n  //       .data(graph.nodes)\n  //     .enter().append(\"g\")\n  //       .attr(\"class\", \"node\")\n  //       .attr(\"transform\", function(d) { \n  //           return \"translate(\" + d.x + \",\" + d.y + \")\"; })\n  //       .call(d3.drag()\n  //         .subject(function(d) {\n  //           return d;\n  //         })\n  //         .on(\"start\", function() {\n  //           this.parentNode.appendChild(this);\n  //         })\n  //         .on(\"drag\", dragmove));\n  //   // add the rectangles for the nodes\n  //   node.append(\"rect\")\n  //       .attr(\"height\", function(d) { return d.dy; })\n  //       .attr(\"width\", sankey.nodeWidth())\n  //       .style(\"fill\", function(d) { \n  //           return d.color = color(d.name.replace(/ .*/, \"\")); })\n  //       .style(\"stroke\", function(d) { \n  //           return d3.rgb(d.color).darker(2); })\n  //     .append(\"title\")\n  //       .text(function(d) { \n  //           return d.name + \"\\n\" + format(d.value); });\n  //   // add in the title for the nodes\n  //   node.append(\"text\")\n  //       .attr(\"x\", -6)\n  //       .attr(\"y\", function(d) { return d.dy / 2; })\n  //       .attr(\"dy\", \".35em\")\n  //       .attr(\"text-anchor\", \"end\")\n  //       .attr(\"transform\", null)\n  //       .text(function(d) { return d.name; })\n  //     .filter(function(d) { return d.x < width / 2; })\n  //       .attr(\"x\", 6 + sankey.nodeWidth())\n  //       .attr(\"text-anchor\", \"start\");\n  //   // the function for moving the nodes\n  //   function dragmove(d) {\n  //     d3.select(this)\n  //       .attr(\"transform\", \n  //             \"translate(\" \n  //                + d.x + \",\" \n  //                + (d.y = Math.max(\n  //                   0, Math.min(height - d.dy, d3.event.y))\n  //                  ) + \")\");\n  //     sankey.relayout();\n  //     link.attr(\"d\", path);\n  //   }\n  // });\n}","map":{"version":3,"sources":["/Users/kevinrayjon/Documents/USC_MS_ADS/Fall_2021/DSCI_554/Project/project-datadocs/demo/src/views/charts/SankeyChart.js"],"names":["d3","drawSankey","height","width"],"mappings":"AAAA,OAAO,KAAKA,EAAZ,MAAoB,IAApB;AAEA,OAAO,SAASC,UAAT,CAAoBC,MAApB,EAA4BC,KAA5B,EAAkC,CAErC;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACH","sourcesContent":["import * as d3 from 'd3';\n\nexport function drawSankey(height, width){\n\n    // d3.sankey = function() {\n    //     var sankey = {},\n    //         nodeWidth = 24,\n    //         nodePadding = 8,\n    //         size = [1, 1],\n    //         nodes = [],\n    //         links = [];\n      \n    //     sankey.nodeWidth = function(_) {\n    //       if (!arguments.length) return nodeWidth;\n    //       nodeWidth = +_;\n    //       return sankey;\n    //     };\n      \n    //     sankey.nodePadding = function(_) {\n    //       if (!arguments.length) return nodePadding;\n    //       nodePadding = +_;\n    //       return sankey;\n    //     };\n      \n    //     sankey.nodes = function(_) {\n    //       if (!arguments.length) return nodes;\n    //       nodes = _;\n    //       return sankey;\n    //     };\n      \n    //     sankey.links = function(_) {\n    //       if (!arguments.length) return links;\n    //       links = _;\n    //       return sankey;\n    //     };\n      \n    //     sankey.size = function(_) {\n    //       if (!arguments.length) return size;\n    //       size = _;\n    //       return sankey;\n    //     };\n      \n    //     sankey.layout = function(iterations) {\n    //       computeNodeLinks();\n    //       computeNodeValues();\n    //       computeNodeBreadths();\n    //       computeNodeDepths(iterations);\n    //       computeLinkDepths();\n    //       return sankey;\n    //     };\n      \n    //     sankey.relayout = function() {\n    //       computeLinkDepths();\n    //       return sankey;\n    //     };\n      \n    //     sankey.link = function() {\n    //       var curvature = .5;\n      \n    //       function link(d) {\n    //         var x0 = d.source.x + d.source.dx,\n    //             x1 = d.target.x,\n    //             xi = d3.interpolateNumber(x0, x1),\n    //             x2 = xi(curvature),\n    //             x3 = xi(1 - curvature),\n    //             y0 = d.source.y + d.sy + d.dy / 2,\n    //             y1 = d.target.y + d.ty + d.dy / 2;\n    //         return \"M\" + x0 + \",\" + y0\n    //              + \"C\" + x2 + \",\" + y0\n    //              + \" \" + x3 + \",\" + y1\n    //              + \" \" + x1 + \",\" + y1;\n    //       }\n      \n    //       link.curvature = function(_) {\n    //         if (!arguments.length) return curvature;\n    //         curvature = +_;\n    //         return link;\n    //       };\n      \n    //       return link;\n    //     };\n      \n    //     // Populate the sourceLinks and targetLinks for each node.\n    //     // Also, if the source and target are not objects, assume they are indices.\n    //     function computeNodeLinks() {\n    //       nodes.forEach(function(node) {\n    //         node.sourceLinks = [];\n    //         node.targetLinks = [];\n    //       });\n    //       links.forEach(function(link) {\n    //         var source = link.source,\n    //             target = link.target;\n    //         if (typeof source === \"number\") source = link.source = nodes[link.source];\n    //         if (typeof target === \"number\") target = link.target = nodes[link.target];\n    //         source.sourceLinks.push(link);\n    //         target.targetLinks.push(link);\n    //       });\n    //     }\n      \n    //     // Compute the value (size) of each node by summing the associated links.\n    //     function computeNodeValues() {\n    //       nodes.forEach(function(node) {\n    //         node.value = Math.max(\n    //           d3.sum(node.sourceLinks, value),\n    //           d3.sum(node.targetLinks, value)\n    //         );\n    //       });\n    //     }\n      \n    //     // Iteratively assign the breadth (x-position) for each node.\n    //     // Nodes are assigned the maximum breadth of incoming neighbors plus one;\n    //     // nodes with no incoming links are assigned breadth zero, while\n    //     // nodes with no outgoing links are assigned the maximum breadth.\n    //     function computeNodeBreadths() {\n    //       var remainingNodes = nodes,\n    //           nextNodes,\n    //           x = 0;\n      \n    //       while (remainingNodes.length) {\n    //         nextNodes = [];\n    //         remainingNodes.forEach(function(node) {\n    //           node.x = x;\n    //           node.dx = nodeWidth;\n    //           node.sourceLinks.forEach(function(link) {\n    //             if (nextNodes.indexOf(link.target) < 0) {\n    //               nextNodes.push(link.target);\n    //             }\n    //           });\n    //         });\n    //         remainingNodes = nextNodes;\n    //         ++x;\n    //       }\n      \n    //       //\n    //       moveSinksRight(x);\n    //       scaleNodeBreadths((size[0] - nodeWidth) / (x - 1));\n    //     }\n      \n    //     function moveSourcesRight() {\n    //       nodes.forEach(function(node) {\n    //         if (!node.targetLinks.length) {\n    //           node.x = d3.min(node.sourceLinks, function(d) { return d.target.x; }) - 1;\n    //         }\n    //       });\n    //     }\n      \n    //     function moveSinksRight(x) {\n    //       nodes.forEach(function(node) {\n    //         if (!node.sourceLinks.length) {\n    //           node.x = x - 1;\n    //         }\n    //       });\n    //     }\n      \n    //     function scaleNodeBreadths(kx) {\n    //       nodes.forEach(function(node) {\n    //         node.x *= kx;\n    //       });\n    //     }\n      \n    //     function computeNodeDepths(iterations) {\n    //       var nodesByBreadth = d3.nest()\n    //           .key(function(d) { return d.x; })\n    //           .sortKeys(d3.ascending)\n    //           .entries(nodes)\n    //           .map(function(d) { return d.values; });\n      \n    //       //\n    //       initializeNodeDepth();\n    //       resolveCollisions();\n    //       for (var alpha = 1; iterations > 0; --iterations) {\n    //         relaxRightToLeft(alpha *= .99);\n    //         resolveCollisions();\n    //         relaxLeftToRight(alpha);\n    //         resolveCollisions();\n    //       }\n      \n    //       function initializeNodeDepth() {\n    //         var ky = d3.min(nodesByBreadth, function(nodes) {\n    //           return (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value);\n    //         });\n      \n    //         nodesByBreadth.forEach(function(nodes) {\n    //           nodes.forEach(function(node, i) {\n    //             node.y = i;\n    //             node.dy = node.value * ky;\n    //           });\n    //         });\n      \n    //         links.forEach(function(link) {\n    //           link.dy = link.value * ky;\n    //         });\n    //       }\n      \n    //       function relaxLeftToRight(alpha) {\n    //         nodesByBreadth.forEach(function(nodes, breadth) {\n    //           nodes.forEach(function(node) {\n    //             if (node.targetLinks.length) {\n    //               var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);\n    //               node.y += (y - center(node)) * alpha;\n    //             }\n    //           });\n    //         });\n      \n    //         function weightedSource(link) {\n    //           return center(link.source) * link.value;\n    //         }\n    //       }\n      \n    //       function relaxRightToLeft(alpha) {\n    //         nodesByBreadth.slice().reverse().forEach(function(nodes) {\n    //           nodes.forEach(function(node) {\n    //             if (node.sourceLinks.length) {\n    //               var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);\n    //               node.y += (y - center(node)) * alpha;\n    //             }\n    //           });\n    //         });\n      \n    //         function weightedTarget(link) {\n    //           return center(link.target) * link.value;\n    //         }\n    //       }\n      \n    //       function resolveCollisions() {\n    //         nodesByBreadth.forEach(function(nodes) {\n    //           var node,\n    //               dy,\n    //               y0 = 0,\n    //               n = nodes.length,\n    //               i;\n      \n    //           // Push any overlapping nodes down.\n    //           nodes.sort(ascendingDepth);\n    //           for (i = 0; i < n; ++i) {\n    //             node = nodes[i];\n    //             dy = y0 - node.y;\n    //             if (dy > 0) node.y += dy;\n    //             y0 = node.y + node.dy + nodePadding;\n    //           }\n      \n    //           // If the bottommost node goes outside the bounds, push it back up.\n    //           dy = y0 - nodePadding - size[1];\n    //           if (dy > 0) {\n    //             y0 = node.y -= dy;\n      \n    //             // Push any overlapping nodes back up.\n    //             for (i = n - 2; i >= 0; --i) {\n    //               node = nodes[i];\n    //               dy = node.y + node.dy + nodePadding - y0;\n    //               if (dy > 0) node.y -= dy;\n    //               y0 = node.y;\n    //             }\n    //           }\n    //         });\n    //       }\n      \n    //       function ascendingDepth(a, b) {\n    //         return a.y - b.y;\n    //       }\n    //     }\n      \n    //     function computeLinkDepths() {\n    //       nodes.forEach(function(node) {\n    //         node.sourceLinks.sort(ascendingTargetDepth);\n    //         node.targetLinks.sort(ascendingSourceDepth);\n    //       });\n    //       nodes.forEach(function(node) {\n    //         var sy = 0, ty = 0;\n    //         node.sourceLinks.forEach(function(link) {\n    //           link.sy = sy;\n    //           sy += link.dy;\n    //         });\n    //         node.targetLinks.forEach(function(link) {\n    //           link.ty = ty;\n    //           ty += link.dy;\n    //         });\n    //       });\n      \n    //       function ascendingSourceDepth(a, b) {\n    //         return a.source.y - b.source.y;\n    //       }\n      \n    //       function ascendingTargetDepth(a, b) {\n    //         return a.target.y - b.target.y;\n    //       }\n    //     }\n      \n    //     function center(node) {\n    //       return node.y + node.dy / 2;\n    //     }\n      \n    //     function value(link) {\n    //       return link.value;\n    //     }\n      \n    //     return sankey;\n    //   };\n    \n    // /////////////////////////////////////////////////////////////////\n    \n    \n    // var units = \"Widgets\";\n    \n    // // set the dimensions and margins of the graph\n    // var margin = {top: 10, right: 10, bottom: 10, left: 10},\n    //     width = 900 - margin.left - margin.right,\n    //     height = 300 - margin.top - margin.bottom;\n    \n    // // format variables\n    // var formatNumber = d3.format(\",.0f\"),    // zero decimal places\n    //     format = function(d) { return formatNumber(d) + \" \" + units; },\n    //     color = d3.scaleOrdinal(d3.schemeCategory10);\n    //     // color = [\"#003f5c\",\"#2f4b7c\",\"#665191\",\"#a05195\",\"#d45087\",\"#f95d6a\",\"#ff7c43\",\"#ffa600\",\"#003f5c\",\"#2f4b7c\"];\n    \n    \n    // // append the svg object to the body of the page\n    // var svg = d3.select('#sankey1').append(\"svg\")\n    //     .attr(\"width\", width + margin.left + margin.right)\n    //     .attr(\"height\", height + margin.top + margin.bottom)\n    //   .append(\"g\")\n    //     .attr(\"transform\", \n    //           \"translate(\" + margin.left + \",\" + margin.top + \")\");\n    \n    // // Set the sankey diagram properties\n    // var sankey = d3.sankey()\n    //     .nodeWidth(36)\n    //     .nodePadding(40)\n    //     .size([width, height]);\n    \n    // var path = sankey.link();\n    \n    // sankey_data = d3.csv(\"https://raw.githubusercontent.com/Heun-Johnson/dsci554projectdata/main/sankey.csv\")\n    // // load the data\n    // d3.csv(sankey_data, function(error, data) {\n     \n    //   //set up graph in same style as original example but empty\n    //   graph = {\"nodes\" : [], \"links\" : []};\n    \n    //   data.forEach(function (d) {\n    //     graph.nodes.push({ \"name\": d.source });\n    //     graph.nodes.push({ \"name\": d.target });\n    //     graph.links.push({ \"source\": d.source,\n    //                        \"target\": d.target,\n    //                        \"value\": +d.value });\n    //    });\n    \n    //   // return only the distinct / unique nodes\n    //   graph.nodes = d3.keys(d3.nest()\n    //     .key(function (d) { return d.name; })\n    //     .object(graph.nodes));\n    \n    //   // loop through each link replacing the text with its index from node\n    //   graph.links.forEach(function (d, i) {\n    //     graph.links[i].source = graph.nodes.indexOf(graph.links[i].source);\n    //     graph.links[i].target = graph.nodes.indexOf(graph.links[i].target);\n    //   });\n    \n    //   // now loop through each nodes to make nodes an array of objects\n    //   // rather than an array of strings\n    //   graph.nodes.forEach(function (d, i) {\n    //     graph.nodes[i] = { \"name\": d };\n    //   });\n    \n    //   sankey\n    //       .nodes(graph.nodes)\n    //       .links(graph.links)\n    //       .layout(32);\n    \n    //   // add in the links\n    //   var link = svg.append(\"g\").selectAll(\".link\")\n    //       .data(graph.links)\n    //     .enter().append(\"path\")\n    //       .attr(\"class\", \"link\")\n    //       .attr(\"d\", path)\n    //       .style(\"stroke-width\", function(d) { return Math.max(1, d.dy); })\n    //       .sort(function(a, b) { return b.dy - a.dy; });\n    \n    //   // add the link titles\n    //   link.append(\"title\")\n    //         .text(function(d) {\n    //             return d.source.name + \" → \" + \n    //                 d.target.name + \"\\n\" + format(d.value); });\n    \n    //   // add in the nodes\n    //   var node = svg.append(\"g\").selectAll(\".node\")\n    //       .data(graph.nodes)\n    //     .enter().append(\"g\")\n    //       .attr(\"class\", \"node\")\n    //       .attr(\"transform\", function(d) { \n    //           return \"translate(\" + d.x + \",\" + d.y + \")\"; })\n    //       .call(d3.drag()\n    //         .subject(function(d) {\n    //           return d;\n    //         })\n    //         .on(\"start\", function() {\n    //           this.parentNode.appendChild(this);\n    //         })\n    //         .on(\"drag\", dragmove));\n    \n    //   // add the rectangles for the nodes\n    //   node.append(\"rect\")\n    //       .attr(\"height\", function(d) { return d.dy; })\n    //       .attr(\"width\", sankey.nodeWidth())\n    //       .style(\"fill\", function(d) { \n    //           return d.color = color(d.name.replace(/ .*/, \"\")); })\n    //       .style(\"stroke\", function(d) { \n    //           return d3.rgb(d.color).darker(2); })\n    //     .append(\"title\")\n    //       .text(function(d) { \n    //           return d.name + \"\\n\" + format(d.value); });\n    \n    //   // add in the title for the nodes\n    //   node.append(\"text\")\n    //       .attr(\"x\", -6)\n    //       .attr(\"y\", function(d) { return d.dy / 2; })\n    //       .attr(\"dy\", \".35em\")\n    //       .attr(\"text-anchor\", \"end\")\n    //       .attr(\"transform\", null)\n    //       .text(function(d) { return d.name; })\n    //     .filter(function(d) { return d.x < width / 2; })\n    //       .attr(\"x\", 6 + sankey.nodeWidth())\n    //       .attr(\"text-anchor\", \"start\");\n    \n    //   // the function for moving the nodes\n    //   function dragmove(d) {\n    //     d3.select(this)\n    //       .attr(\"transform\", \n    //             \"translate(\" \n    //                + d.x + \",\" \n    //                + (d.y = Math.max(\n    //                   0, Math.min(height - d.dy, d3.event.y))\n    //                  ) + \")\");\n    //     sankey.relayout();\n    //     link.attr(\"d\", path);\n    //   }\n    // });\n}\n"]},"metadata":{},"sourceType":"module"}